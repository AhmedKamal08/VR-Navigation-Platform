//MIT License
//Copyright (c) 2020 Sean Bradley
//https://github.com/Sean-Bradley/TeleportVR/blob/master/LICENSE
import * as THREE from '/build/three.module.js';
var group = new THREE.Group();
var newPos = new THREE.Vector3();
var oldPos = new THREE.Vector3();
var intersects;
var trueDirection = new THREE.Vector3;
var finalDirection = new THREE.Vector3;
var targetSphere;
var arrow;
var target = new THREE.Group();
let points = [];
var bboxLength = 13.34;
const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
var blinkerSphereMaterial = new THREE.MeshBasicMaterial({
    side: THREE.BackSide,

    color: 0xADADA8,
    transparent: true,
    opacity: 0.9,
    depthTest: false
    //  colorWrite: false
});
let workingMatrix = new THREE.Matrix4();
let blocked;
let dist;
let controller1Rotation;
let R = [0, 0.78, 0.85, 1]
let blinkSpheres = [];
for (var i = 0; i <= 4; i += 1) {
    //console.log(i);
    var tempSphereGeometry = new THREE.SphereBufferGeometry(3, 64, 8, 0, Math.PI * 2, 0, Math.PI * R[i]);

    tempSphereGeometry.translate(0, 0.3, 0);

    var tempSphere = new THREE.Mesh(
        tempSphereGeometry, blinkerSphereMaterial
    );


    tempSphere.rotation.set(Math.PI / 2, 0, 0);
    tempSphere.position.set(0, 1.5, 4.0);
    tempSphere.visible = false;
    // group.add(tempSphere);




    blinkSpheres.push(tempSphere);
}


export default class TeleportVR {
    constructor(scene, dolly, mode) {

        this._colliders = [];
        this._curve = new THREE.Mesh();
        this._maxDistance = 10;

        this._MaxDistanceFunction = "";
        this._TeleportDelayFunction = "";

        this._delay = 900;

        this._visible = false;
        this._activeController = new THREE.Object3D();
        this._mode = "blur";
        this._radiusIndex = 2;
        this._activeControllerKey = "";
        this._controllers = {};
        this._enabled = {};
        this._gamePads = {};
        this._raycaster = new THREE.Raycaster();
        this._raycaster2 = new THREE.Raycaster();
        this._raycaster3 = new THREE.Raycaster();

        //blinkSpheres[2].visible = true;
        for (var i = 0; i <= 4; i++) {
            dolly.children[0].attach(blinkSpheres[i]);

        }
        //  console.log(dolly);

        group = dolly;
        // console.log(group);

        scene.add(group);
        group.add(target);

        this._vectorArray = new THREE.QuadraticBezierCurve3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 7, -1), new THREE.Vector3(2, 0, -2));
        const _mesh = new THREE.Mesh(new THREE.CylinderBufferGeometry(.5, .5, .01, 8), new THREE.MeshBasicMaterial({
            color: 0x0044ff,
            wireframe: true
        }));

        _mesh.name = "helperTarget";
        target.add(_mesh);
        const _mesh2 = new THREE.Mesh(new THREE.BoxBufferGeometry(.1, .1, 1), new THREE.MeshBasicMaterial({
            color: 0x0044ff,
            wireframe: true
        }));
        _mesh2.translateZ(-.8);
        _mesh2.name = "helperDirection";
        target.add(_mesh2);
        target.visible = false;
        const _geometry = new THREE.TubeBufferGeometry(this._vectorArray, 3, .1, 5, false);

        this._curve = new THREE.Mesh(_geometry, new THREE.MeshBasicMaterial({
            color: 0xff0000,
            wireframe: false
        }));
        //this._curve.rotateY(1);
        this._curve.visible = false;
        group.add(this._curve);
        const direction = new THREE.Vector3(0, -1, 0);
        this._raycaster.ray.direction.copy(direction);

        var targettest = new THREE.SphereBufferGeometry(.5, 64, 4, 0, Math.PI * 2, 0, Math.PI);
        targetSphere = new THREE.Mesh(
            targettest, blinkerSphereMaterial
        );
        arrow = new THREE.ArrowHelper(this._raycaster.ray.direction, this._raycaster.ray.origin, 100, 0xff0000);
        target.getWorldPosition(this._raycaster.ray.origin);
        //scene.add(arrow);
        //scene.add(targetSphere);

    }

    add(id, model, gamePad) {
        model.name = "teleportVRController_" + id.toString();
        group.add(model);
        this._controllers[id] = model;
        this._gamePads[id] = gamePad;
        this._enabled[id] = true;
        //console.log("gamepads length = " + Object.keys(this._gamePads).length)
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(value) {
        this._enabled = value;
    }
    get gamePads() {
        return this._gamePads;
    }
    set gamePads(value) {
        this._gamePads = value;
    }
    get target() {
        return target;
    }
    set target(value) {
        target = value;
    }
    get curve() {
        return this._curve;
    }
    set curve(value) {
        this._curve = value;
    }

    setNewMaxDistance(value) {
        this._MaxDistanceFunction = value;
    }

    setNewTeleDelay(value) {
        this._TeleportDelayFunction = value;
    }
    useDefaultTargetHelper(use) {
        target.getObjectByName("helperTarget").visible = use;
    }
    useDefaultDirectionHelper(use) {
        target.getObjectByName("helperDirection").visible = use;
    }
    setMaxDistance(val) {
        this._maxDistance = val;
        console.log(val);
    }
    setMode(val) {
        this._mode = val;
        //console.log("54354354");

    }
    setcolliders(val) {
        this._colliders = val;
    }
    setraduisIndex(val) {
        this._radiusIndex = val;
    }

    setCustom(val) {
        this._coustomVariables = val;
    }
    teleport() {
        //this.blinkerSphereGeometry1 = blinkSpheres[0];


        // dolly.getWorldPosition(blinkSpheres[2].position);
        // group.children[2].children[0].visible=false;
        // group.children[3].children[0].visible=false;
        //console.log(group);





        var temp = new THREE.Vector3();
        target.getWorldPosition(temp);

        var R = this._radiusIndex;

        this._visible = false;
        target.visible = false;
        this._curve.visible = false;

        if (this._TeleportDelayFunction != "") {
            var s = eval('(function() {' + this._TeleportDelayFunction + '}())');
            this._delay = s;

        }

        if (!this._coustomVariables) {

           

        }
        console.log(this._delay);


        if (this._mode == "blur") {
            console.log(this._raycaster);


            dist = temp.length();
            console.log(this._maxDistance);
            blinkSpheres[R].visible = true;
            blinkSpheres[R].scale.set(2, 2, 2);
            blinkSpheres[R].material.color.setHex(0xADADA8);
            //  blinkSpheres[R].material
            new TWEEN.Tween(blinkSpheres[R].scale)
                .to({ x: 4, y: 4, z: 4 }, 600)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
            new TWEEN.Tween(group.position)
                .delay(400)
                .to({ x: temp.x, y: temp.y, z: temp.z }, this._delay).start()
                .chain(
                    new TWEEN.Tween(blinkSpheres[R].scale)
                        .to({ x: 1, y: 1, z: 1 }, 400)
                        .onComplete(() => blinkSpheres[R].visible = false)).start();
        }

        if (this._mode == "blink") {

           // blinkSpheres[R].material.transparent = false;
            blinkSpheres[R].visible = true;
            blinkSpheres[R].material.opacity = 0;
            blinkSpheres[R].material.color.setHex(0x000000)
            blinkSpheres[R].scale.set(2, 2, 2);
            // console.log("ddd22d");
            new TWEEN.Tween(blinkSpheres[R].material)
                .to({ opacity: 1 }, 1000)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(function () {

                    // Do the teleport
                    target.getWorldPosition(group.position);
                    target.getWorldQuaternion(group.quaternion);

                    // Fade back
                    new TWEEN.Tween(blinkSpheres[R].material)
                        .to({ opacity: 0 }, 1000)
                        .onComplete(() => blinkSpheres[R].visible = false)
                        .start();
                })
                .start();

        }





    }
    update(elevationsMeshList) {
        // target.rotation.y = group.children[1].rotation.y;
        controller1Rotation = group.children[1].quaternion.clone();
        //target.getWorldQuaternion(controller1Rotation);
        if (Object.keys(this._gamePads).length > 0) {
            for (let key in Object.keys(this._gamePads)) {
                if (this._enabled[key]) {
                    const gp = this._gamePads[key];
                    //console.log(gp);
                    if (gp.buttons[3].pressed) {
                        //console.log("hapticActuators = " + gp.hapticActuators)
                        //console.log(gp.axes[0] + " " + gp.axes[1] + " " + gp.axes[2] + " " + gp.axes[3])
                        this._activeController = this._controllers[key];
                        this._activeController.rotateX(-30);
                        this._activeControllerKey = key;
                        this._visible = true;
                        if (Math.abs(gp.axes[2]) + Math.abs(gp.axes[3]) > 0.25) {
                            target.rotation.y = Math.atan2(-gp.axes[2], -gp.axes[3]); //angle degrees
                        }
                        target.visible = true;
                        this._curve.visible = true;
                        break;
                    }
                    else {
                        if (this._activeControllerKey === key) {
                            this._activeControllerKey = "";
                            if (!blocked) this.teleport();
                            target.rotation.y = 0;

                        }
                    }
                }
            }
        }
        if (this._visible) {
            const v = new THREE.Vector3(0, -1, 0);




            targetSphere.position.copy(target.position);
            targetSphere.position.z -= .5;
            targetSphere.position.y += 2;

            //console.log(targetSphere.position );
            intersects = [];

            if (this._MaxDistanceFunction != "") {
                var s = eval('(function() {' + this._MaxDistanceFunction + '}())');
                this._maxDistance = s;

            }
        
            v.applyQuaternion(this._activeController.quaternion);
            //target.distanceTo() 
            newPos = new THREE.Vector3(v.x * this._maxDistance, 0, v.z * this._maxDistance);

            //this._raycaster.ray.origin.setFromMatrixPosition(target.matrixWorld);
            target.getWorldPosition(this._raycaster.ray.origin);
         this._raycaster.ray.origin.y += 2;
            //this._raycaster.ray.origin.z -= 5;

            if (oldPos != newPos) {

              //  console.log("new!=old");
                trueDirection.subVectors(newPos, oldPos);

                trueDirection.normalize();
                //  trueDirection.negate();
                // console.log(trueDirection);
                this._raycaster.ray.direction.set(trueDirection.x, trueDirection.y, trueDirection.z);

                var intersects = this._raycaster.intersectObjects(this._colliders);

                blocked = false;
               
                if (intersects.length > 0 && intersects[0].distance <= 2) {



                    blocked = true;

                    let newZ = intersects[0].point.z - group.position.z;
                    let newX = intersects[0].point.x - group.position.x
                    target.children[0].material.color.setHex(0xff0000);

                    target.position.set(newX, 0, newZ);
                    if (controller1Rotation.x > .3 || controller1Rotation.x < -.8) {
                        //intersects="";
                        blocked = false;
                        target.children[0].material.color.setHex(0x0044ff);
                        ///console.log("d");
                        target.position.set(v.x * this._maxDistance, 0, v.z * this._maxDistance);
                    }



                }

 



                else {
                    oldPos = new THREE.Vector3(v.x * this._maxDistance, 0, v.z * this._maxDistance);
                    target.position.set(v.x * this._maxDistance, 0, v.z * this._maxDistance);

                    target.children[0].material.color.setHex(0x0044ff);

                    //  console.log("dsdss");
                }


            }

             

            this._vectorArray.v0.copy(target.position);
            this._vectorArray.v2.copy(this._activeController.position);
            var midPoint = new THREE.Object3D();
            midPoint.position.copy(this._vectorArray.v2);
            midPoint.quaternion.copy(this._activeController.quaternion);
            midPoint.translateY(-3);
            this._vectorArray.v1.copy(midPoint.position);
            const t = new THREE.TubeBufferGeometry(this._vectorArray, 20, .01, 11, false);
            this._curve.geometry.copy(t);
        }
    }
}
