


//MIT License
//Copyright (c) 2020 Sean Bradley
//https://github.com/Sean-Bradley/TeleportVR/blob/master/LICENSE
import * as THREE from '/build/three.module.js';
var group2 = new THREE.Group();

var blinkerSphereMaterial = new THREE.MeshBasicMaterial({
    side: THREE.BackSide,

    color: 0xADADA8,
    transparent: true,
    opacity: 0.9,
    depthTest: false
});
let pressed;
let dt;
let camera;
let cameraPosition = new THREE.Vector3();
let Controller1Position = new THREE.Vector3();
//let Controller1Position = new THREE.Vector3();


let cameraForward = new THREE.Vector3();
let Controller1;
let Controller1Forward = new THREE.Vector3();
let Controller2;
let Controller2Forward = new THREE.Vector3();


let CameraRotaion ;

let Controller1Rotation  ;

let Controller1Rotaion ;



let mark = new THREE.Vector3(3, 0, -4.3);
let test = new THREE.Vector3();;
let R = [0, 0.75, 0.85, 1]
let blinkSphersN = [];
for (var i = 0; i <= 4; i += 1) {

    var tempSphereGeometry = new THREE.SphereBufferGeometry(0.9, 64, 8, 0, Math.PI * 2, 0, Math.PI * R[i]);

    tempSphereGeometry.translate(0, 0.3, 0);

    var tempSphere = new THREE.Mesh(
        tempSphereGeometry, blinkerSphereMaterial
    );


    tempSphere.rotation.set(Math.PI / 2, 0, 0);
    tempSphere.position.set(0, 1.6, 2.5);
    tempSphere.visible = false;
    // group2.add(tempSphere);




    blinkSphersN.push(tempSphere);
}

var cameraWorldRotaion = new THREE.Quaternion();
var cameraWorldPosition = new THREE.Vector3();
var camerascale = new THREE.Vector3();
var raycaster = new THREE.Raycaster();


export default class FlyingVR {
    constructor(scene, dolly, mode) {
        this._speed = 2;
        dt = 0;
        pressed = "";
        this._camera = dolly.children[0];
        this._colliders = [];
        this._AllowFlying = false;
        this._forward = new THREE.Quaternion();


        this._speedFunction = "";
        this._forwardFunction = "";
        this._pressedFunction = "";
        this._coustomVariables = false;

        this._newpressed = "";
        this._visible = false;
        this._activeController = new THREE.Object3D();
        this._mode = "blur";
        this._radiusIndex = 1;
        this._activeControllerKey = "";
        this._controllers = {};
        this._enabled = {};
        this._gamePads = {};
        this._raycaster = new THREE.Raycaster();
        //blinkSphersN[2].visible = true;
        for (var i = 0; i <= 4; i++) {
            dolly.children[0].attach(blinkSphersN[i]);

        }

        group2 = dolly;
        scene.add(group2);

        console.log(group2);
        const direction = new THREE.Vector3(0, -1, 0);
        this._raycaster.ray.direction.copy(direction);


        // console.log(group2);

    }

    add(id, model, gamePad) {
        model.name = "teleportVRController_" + id.toString();
        group2.add(model);
        this._controllers[id] = model;
        this._gamePads[id] = gamePad;
        this._enabled[id] = true;
        //console.log("gamepads length = " + Object.keys(this._gamePads).length)
    }


    setCustom(val) {
        this._coustomVariables = val;
    }
    setNewSpeed(val) {
        this._speedFunction = val;
    }
    setNewForward(val) {
        this._forwardFunction = val;
    }
    setNewTrigger(val) {
        this._pressedFunction = val;
    }

    setForward(val) {
        this._forward = val;

    }
    setspeed(val) {
        this._speed = val;
        //  console.log(val);
    }
    setcolliders(val) {
        this._colliders = val;
    }
    setMode(val) {
        this._mode = val;
    }
    setraduisIndex(val) {
        this._radiusIndex = val;
    }
    setAllowFlying(val) {
        this._AllowFlying = val;
    }

    setPressed(val) {
        pressed = val;

    }

    setDeltaTime(val) {
        dt = val;

    }
    getPressed() {
        return pressed;
    }
    fly() {
        this._camera.matrixWorld.decompose(cameraWorldPosition, cameraWorldRotaion, camerascale);


        //  this._forward= CameraRotaion;

        // camera = group2.children[0];
        // CameraRotaion = group2.children[0].quaternion.clone();
        //Controller1 = group2.children[5];
        //Controller1Rotation = group2.children[5].quaternion.clone();
        ////Controller1 = group2.children[6];
        //Controller1Rotaion = group2.children[6].quaternion.clone();


        if (this._speedFunction != "") {
            var s = eval('(function() {' + this._speedFunction + '}())');
            this._speed = s;
            // console.log(s)
        }

        if (this._forwardFunction != "") {
            var s = eval('(function() {' + this._forwardFunction + '}())');
            this._forward = s;

        }



        if (!this._coustomVariables) {

            this._forward = cameraForward;

        }
        //console.log(group2);

        var R = this._radiusIndex;

        // var controllerdRotaion = new THREE.Quaternion();

        // controllerdRotaion = group2.children[5].quaternion.clone();
        const wallLimit = 1.3;

        let pos = group2.position.clone();
        pos.y += 1;


        //console.log(this._forward);
        let dir = new THREE.Vector3();
        dir = this._forward.clone();
        //Store original dolly rotation
        var quaternion1 = group2.quaternion.clone();
        //Get rotation for movement from the headset pose
        //group2.quaternion.copy(this._forward);
        //group2.getWorldDirection(dir);
        dir.negate();
        raycaster.set(pos, dir);

        let blocked = false;

        let intersect = raycaster.intersectObjects(this._colliders);
        if (intersect.length > 0) {
            // console.log(intersect[0].distance);

            if (intersect[0].distance < wallLimit) {

                blocked = true;
            }

        }

        // dir.set(0, -1, 0);
        // pos.y += 2;
        // raycaster.set(pos, dir);
        //  intersect = raycaster.intersectObjects(this._colliders);
        // if (intersect.length > 0&&intersect[0].distance <=1 ) {
        //     console.log("s");
        //     group2.position.copy(intersect[0].point);
        // }
        // //cast left
        // dir.set(-1, 0, 0);
        // dir.applyMatrix4(group2.matrix);
        // dir.normalize();
        // raycaster.set(pos, dir);

        // intersect = raycaster.intersectObjects(this._colliders);
        // if (intersect.length > 0) {
        //     if (intersect[0].distance < wallLimit) group2.translateX(wallLimit - intersect[0].distance);
        // }

        // //cast right
        // dir.set(1, 0, 0);
        // dir.applyMatrix4(group2.matrix);
        // dir.normalize();
        // raycaster.set(pos, dir);

        // intersect = raycaster.intersectObjects(this._colliders);
        // if (intersect.length > 0) {
        //     if (intersect[0].distance < wallLimit) group2.translateX(intersect[0].distance - wallLimit);
        // }
        // console.log(this._mode)
        if (this._mode == "blur") {
            //blinkSphersN[R].material.colorWrite =false;


            //   console.log();
            blinkSphersN[R].material.transparent = true;

            blinkSphersN[R].visible = true;
            blinkSphersN[R].scale.set(2, 2, 2);


            new TWEEN.Tween(blinkSphersN[R].material)
                .to({ opacity: .9 }, 700)
                .easing(TWEEN.Easing.Quadratic.Out).start();


            // Do the teleport
            if (!blocked) {

                if (this._coustomVariables) {

                    var y = -this._speed;
                    //console.log(y);
                    //group2.translateZ(y);
                    group2.translateOnAxis(this._forward, y);
                }
                if (!this._coustomVariables) {
                    var x = -dt * this._speed;
                    //  let test = new THREE.Vector3();
                    //  Controller1.getWorldDirection(test);
                    //test.negate();
                    group2.translateOnAxis(this._forward, x);
                    // group2.translateZ( x);
                    //   console.log(x);


                }

            }
            if (!this._AllowFlying) {
                group2.position.y = 0;
            }
            //Restore the original rotation
            //group2.quaternion.copy(quaternion1);

        }

        if (this._mode == "blink") {

            blinkSphersN[R].material.transparent = false;
            blinkSphersN[R].visible = true;
            blinkSphersN[R].material.opacity = 0;
            blinkSphersN[R].material.color.setHex(0x000000)
            blinkSphersN[R].scale.set(2, 2, 2);

            new TWEEN.Tween(blinkSphersN[R].material)
                .to({ opacity: 1 }, 700)
                .easing(TWEEN.Easing.Quadratic.Out).start();


            // Do the teleport
            if (!blocked) {
                if (this._coustomVariables) {

                    var y = -this._speed;
                    //console.log(y);
                    //group2.translateZ(y);
                    group2.translateOnAxis(this._forward, y);
                }
                if (!this._coustomVariables) {
                    var x = -dt * this._speed;
                    //  let test = new THREE.Vector3();
                    //  Controller1.getWorldDirection(test);
                    //test.negate();
                    group2.translateOnAxis(this._forward, x);
                    // group2.translateZ( x);
                    //   console.log(x);


                }

            }

            if (!this._AllowFlying) {
                group2.position.y = 0;
            }

            //Restore the original rotation
            //group2.quaternion.copy(quaternion1);

            // Fade back




        }


    }
    update(dt_, elevationsMeshList) {

        camera = group2.children[0];
        camera.getWorldDirection(cameraForward);
        cameraForward.negate();

        Controller1 = group2.children[1];
        Controller1.getWorldDirection(Controller1Forward);

        Controller2 = group2.children[2];
        Controller2.getWorldDirection(Controller2Forward);

        camera.getWorldPosition(cameraPosition);
        Controller1.getWorldPosition(Controller1Position);
         


        CameraRotaion = camera.quaternion.clone();

        Controller1Rotation = Controller1.quaternion.clone();

        Controller1Rotaion = Controller1.quaternion.clone()



        var R = this._radiusIndex;
        test.subVectors(cameraPosition, mark);
        // console.log(test);

        if (!this._coustomVariables) {
            if (pressed == true) {
                this.fly();
                dt = dt_;
                //console.log(this._coustomVariables);
            }
            else {
                // console.log(blinkSphersN[R]);
                new TWEEN.Tween(blinkSphersN[R].material).to({ opacity: 0 }, 600).start();
                blinkSphersN[R].visible = false;
            }
        }

        if (this._coustomVariables) {


            if (this._pressedFunction != "") {
                var s = eval('(function() {' + this._pressedFunction + '}())');
                this._newpressed = s;
                // console.log(s);
            }

            if (this._pressedFunction == "") {

                this._newpressed = pressed;
            }
            if (this._forwardFunction == "") {
                this._forward = cameraForward;

            }

            if (this._newpressed == true) {
                this.fly();
                dt = dt_;

            }
            else {
                // console.log(blinkSphersN[R]);
                new TWEEN.Tween(blinkSphersN[R].material).to({ opacity: 0 }, 600).start();
                blinkSphersN[R].visible = false;
            }
        }
    }
}


