import * as THREE from '/build/three.module.js';
///////////////////////
///group  : Camera + 2 Controllers
var group2 = new THREE.Group();

var blinkerSphereMaterial = new THREE.MeshBasicMaterial({
    side: THREE.BackSide,

    color: 0xADADA8,
    transparent: true,
    opacity: 0.9,
    depthTest: false
});

//exposed variables
let pressed;
let dt;
let camera;
let cameraPosition = new THREE.Vector3();
let Controller1Position = new THREE.Vector3();
let Controller2Position = new THREE.Vector3();


let cameraForward = new THREE.Vector3();
let Controller1;
let Controller1Forward = new THREE.Vector3();
let Controller2;
let Controller2Forward = new THREE.Vector3();
let CameraRotaion;
let Controller1Rotation;
let Controller2Rotaion;
//////////////////////////////////////////////


 // spheres around the camera
let R = [0, 0.75, 0.85, 1]
let blinkSphersN = [];
for (var i = 0; i <= 4; i += 1) {

    var tempSphereGeometry = new THREE.SphereBufferGeometry(0.9, 64, 8, 0, Math.PI * 2, 0, Math.PI * R[i]);

    tempSphereGeometry.translate(0, 0.3, 0);

    var tempSphere = new THREE.Mesh(
        tempSphereGeometry, blinkerSphereMaterial
    );


    tempSphere.rotation.set(Math.PI / 2, 0, 0);
    tempSphere.position.set(0, 1.6, 2.5);
    tempSphere.visible = false;

    blinkSphersN.push(tempSphere);
}
////////////////////////////////////////////////////////
//flaying camera  variables
var cameraWorldRotaion = new THREE.Quaternion();
var cameraWorldPosition = new THREE.Vector3();
var camerascale = new THREE.Vector3();
var raycaster = new THREE.Raycaster();


export default class FlyingVR {
    constructor(scene, dolly, mode) {
        this._speed = 2;
        dt = 0;
        pressed = "";
        this._camera = dolly.children[0];
        this._colliders = [];
        this._AllowFlying = false;
        this._forward = new THREE.Quaternion();


        this._speedFunction = "";
        this._forwardFunction = "";
        this._pressedFunction = "";
        this._coustomVariables = false;

        this._newpressed = "";
        this._visible = false;
        this._activeController = new THREE.Object3D();
        this._mode = "blur";
        this._radiusIndex = 1;
        this._activeControllerKey = "";
        this._controllers = {};
        this._enabled = {};
        this._gamePads = {};
        this._raycaster = new THREE.Raycaster();
        
        for (var i = 0; i <= 4; i++) {
            dolly.children[0].attach(blinkSphersN[i]);

        }

        group2 = dolly;
        scene.add(group2);

        console.log(group2);
        const direction = new THREE.Vector3(0, -1, 0);
        this._raycaster.ray.direction.copy(direction);

    }

    add(id, model, gamePad) {
        model.name = "teleportVRController_" + id.toString();
        group2.add(model);
        this._controllers[id] = model;
        this._gamePads[id] = gamePad;
        this._enabled[id] = true;

    }


    setCustom(val) {
        this._coustomVariables = val;
    }
    setNewSpeed(val) {
        this._speedFunction = val;
    }
    setNewForward(val) {
        this._forwardFunction = val;
    }
    setNewTrigger(val) {
        this._pressedFunction = val;
    }

    setForward(val) {
        this._forward = val;

    }
    setspeed(val) {
        this._speed = val;

    }
    setcolliders(val) {
        this._colliders = val;
    }
    setMode(val) {
        this._mode = val;
    }
    setraduisIndex(val) {
        this._radiusIndex = val;
    }
    setAllowFlying(val) {
        this._AllowFlying = val;
    }

    setPressed(val) {
        pressed = val;

    }

    setDeltaTime(val) {
        dt = val;

    }
    getPressed() {
        return pressed;
    }
    fly() {
        this._camera.matrixWorld.decompose(cameraWorldPosition, cameraWorldRotaion, camerascale);


        if (this._speedFunction != "") {
            var s = eval('(function() {' + this._speedFunction + '}())');
            this._speed = s;

        }

        if (this._forwardFunction != "") {
            var s = eval('(function() {' + this._forwardFunction + '}())');
            this._forward = s;

        }



        if (!this._coustomVariables) {

            this._forward = cameraForward;

        }


        var R = this._radiusIndex;


        const wallLimit = 1.3;

        let pos = group2.position.clone();
        pos.y += 1;



        let dir = new THREE.Vector3();
        dir = this._forward.clone();

        var quaternion1 = group2.quaternion.clone();

        dir.negate();
        raycaster.set(pos, dir);

        let blocked = false;

        let intersect = raycaster.intersectObjects(this._colliders);
        if (intersect.length > 0) {


            if (intersect[0].distance < wallLimit) {

                blocked = true;
            }

        }


        if (this._mode == "blur") {

            blinkSphersN[R].material.transparent = true;

            blinkSphersN[R].visible = true;
            blinkSphersN[R].scale.set(2, 2, 2);


            new TWEEN.Tween(blinkSphersN[R].material)
                .to({ opacity: .9 }, 700)
                .easing(TWEEN.Easing.Quadratic.Out).start();



            if (!blocked) {

                if (this._coustomVariables) {

                    var y = -this._speed;

                    group2.translateOnAxis(this._forward, y);
                }
                if (!this._coustomVariables) {
                    var x = -dt * this._speed;

                    group2.translateOnAxis(this._forward, x);



                }

            }
            if (!this._AllowFlying) {
                group2.position.y = 0;
            }

        }

        if (this._mode == "blink") {

            blinkSphersN[R].material.transparent = false;
            blinkSphersN[R].visible = true;
            blinkSphersN[R].material.opacity = 0;
            blinkSphersN[R].material.color.setHex(0x000000)
            blinkSphersN[R].scale.set(2, 2, 2);

            new TWEEN.Tween(blinkSphersN[R].material)
                .to({ opacity: 1 }, 700)
                .easing(TWEEN.Easing.Quadratic.Out).start();



            if (!blocked) {
                if (this._coustomVariables) {

                    var y = -this._speed;

                    group2.translateOnAxis(this._forward, y);
                }
                if (!this._coustomVariables) {
                    var x = -dt * this._speed;

                    group2.translateOnAxis(this._forward, x);

                }

            }

            if (!this._AllowFlying) {
                group2.position.y = 0;
            }

        }


    }
    update(dt_, elevationsMeshList) {

        camera = group2.children[0];
        camera.getWorldDirection(cameraForward);
        cameraForward.negate();

        Controller1 = group2.children[1];
        Controller1.getWorldDirection(Controller1Forward);

        Controller2 = group2.children[2];
        Controller2.getWorldDirection(Controller2Forward);

        camera.getWorldPosition(cameraPosition);
        Controller1.getWorldPosition(Controller1Position);
        Controller2.getWorldPosition(Controller2Position);

        CameraRotaion = camera.quaternion.clone();

        Controller1Rotation = Controller1.quaternion.clone();
        Controller2Rotaion = Controller2.quaternion.clone()

       var R = this._radiusIndex;
       
        if (!this._coustomVariables) {
            if (pressed == true) {
                this.fly();
                dt = dt_;

            }
            else {
                // console.log(blinkSphersN[R]);
                new TWEEN.Tween(blinkSphersN[R].material).to({ opacity: 0 }, 600).start();
                blinkSphersN[R].visible = false;
            }
        }

        if (this._coustomVariables) {


            if (this._pressedFunction != "") {
                var s = eval('(function() {' + this._pressedFunction + '}())');
                this._newpressed = s;

            }

            if (this._pressedFunction == "") {

                this._newpressed = pressed;
            }
            if (this._forwardFunction == "") {
                this._forward = cameraForward;

            }

            if (this._newpressed == true) {
                this.fly();
                dt = dt_;

            }
            else {

                new TWEEN.Tween(blinkSphersN[R].material).to({ opacity: 0 }, 600).start();
                blinkSphersN[R].visible = false;
            }
        }
    }
}


