//MIT License
//Copyright (c) 2020 Sean Bradley
//https://github.com/Sean-Bradley/TeleportVR/blob/master/LICENSE
import * as THREE from '/build/three.module.js';
import { TeleportMesh } from './TeleportMesh.js'
var group2 = new THREE.Group();
const clock1 = new THREE.Clock();
var blinkerSphereMaterial = new THREE.MeshBasicMaterial({
    side: THREE.BackSide,

    color: 0xADADA8,
    transparent: true,
    opacity: 0.9
    //  colorWrite: false
});
let pressed;
let dt;
let camera;
let cameraRotaion;
let controller1;
let controller1Rotation;
let controller2;
let controller2Rotaion;

let Scene;
let R = [0, 0.75, 0.85, 1]
let blinkSphersN = [];

const locations = [
    //new THREE.Vector3(-0.409, 0, 4.038),
    // new THREE.Vector3(-0.846, 0, 5.777),
    //new THREE.Vector3(5.220, 0, 2.677),
    new THREE.Vector3(1, 0, -3.599),
    //new THREE.Vector3(7.565, 0, 0.008),
    //new THREE.Vector3(-8.417, 2.676, 0.192),
    // new THREE.Vector3(-6.644, 0, -4.114)
];


for (var i = 0; i <= 4; i += 1) {

    var tempSphereGeometry = new THREE.SphereBufferGeometry(0.9, 64, 8, 0, Math.PI * 2, 0, Math.PI * R[i]);

    tempSphereGeometry.translate(0, 0.3, 0);

    var tempSphere = new THREE.Mesh(
        tempSphereGeometry, blinkerSphereMaterial
    );


    tempSphere.rotation.set(Math.PI / 2, 0, 0);
    tempSphere.position.set(0, 1.6, 2.5);
    tempSphere.visible = false;
    // group2.add(tempSphere);




    blinkSphersN.push(tempSphere);
}

var cameraWorldRotaion = new THREE.Quaternion();
var cameraWorldPosition = new THREE.Vector3();
var camerascale = new THREE.Vector3();
var raycaster = new THREE.Raycaster();
let teleports = [];

export default class FlyingVR {
    constructor(scene, dolly, mode) {
        this._speed = 2;
        dt = 0;
        pressed = "";
        this._camera = dolly.children[0];
        this._colliders = [];
        this._TPoints = [];

        this._AllowFlying = true;
        this._forward = new THREE.Quaternion();


        this.workingMatrix = new THREE.Matrix4();

        this._speedFunction = "";
        this._forwardFunction = "";
        this._pressedFunction = "";
        this._coustomVariables = false;

        this._newpressed = "";
        this._visible = false;
        this._activeController = new THREE.Object3D();
        this._mode = "blur";
        this._radiusIndex = 1;
        this._activeControllerKey = "";
        this._controllers = {};
        this._enabled = {};
        this._gamePads = {};
        this._raycaster = new THREE.Raycaster();
        //blinkSphersN[2].visible = true;
        for (var i = 0; i <= 4; i++) {
            dolly.children[0].attach(blinkSphersN[i]);

        }

        group2 = dolly;
        scene.add(group2);

        console.log(group2);
        const direction = new THREE.Vector3(0, -1, 0);
        this._raycaster.ray.direction.copy(direction);



        // locations.forEach(myFunction);

        // function myFunction(item, index) {
        //     const teleport = new TeleportMesh( );
        //     teleport.position.copy(item);
        //     scene.add(teleport);
        //     teleports.push(teleport);

        // }
        teleports.forEach(teleport => this._colliders.push(teleport.children[0]));

        console.log(this._colliders);


        Scene = scene;
    }

    add(id, model, gamePad) {
        model.name = "teleportVRController_" + id.toString();
        group2.add(model);
        this._controllers[id] = model;
        this._gamePads[id] = gamePad;
        this._enabled[id] = true;
        //console.log("gamepads length = " + Object.keys(this._gamePads).length)
    }


    setCustom(val) {
        this._coustomVariables = val;
    }
    setNewSpeed(val) {
        this._speedFunction = val;
    }
    setNewForward(val) {
        this._forwardFunction = val;
    }
    setNewTrigger(val) {
        this._pressedFunction = val;
    }

    setForward(val) {
        this._forward = val;

    }
    setspeed(val) {
        this._speed = val;
        //  console.log(val);
    }
    setcolliders(val) {
        this._colliders = val;
    }
    setTPoints(val) {
        this._TPoints = val;
        console.log(this._TPoints);
    }
    setMode(val) {
        this._mode = val;
    }
    setraduisIndex(val) {
        this._radiusIndex = val;
    }
    setAllowFlying(val) {
        this._AllowFlying = val;
    }

    setPressed(val) {
        pressed = val;

    }

    setDeltaTime(val) {
        dt = val;

    }
    getPressed() {
        return pressed;
    }
    fly() {
        this._camera.matrixWorld.decompose(cameraWorldPosition, cameraWorldRotaion, camerascale);

        if (!this._coustomVariables) {

            this._forward = cameraRotaion;

        }
        //console.log(group2);

        var R = this._radiusIndex;

        var controllerdRotaion = new THREE.Quaternion();

        controllerdRotaion = group2.children[5].quaternion.clone();
        const wallLimit = 1.3;

        let pos = group2.position.clone();
        pos.y += 1;


        //console.log(group2.children[1].quaternion);

        // console.log(this._mode)
        if (this._mode == "blur") {
            //blinkSphersN[R].material.colorWrite =false;


            //   console.log();
            blinkSphersN[R].material.transparent = true;

            blinkSphersN[R].visible = true;
            blinkSphersN[R].scale.set(2, 2, 2);


            new TWEEN.Tween(blinkSphersN[R].material)
                .to({ opacity: .9 }, 700)
                .easing(TWEEN.Easing.Quadratic.Out).start();


            // Do the teleport


            if (this._coustomVariables) {

                var y = -this._speed;
                //console.log(y);
                // group2.translateZ(y);
            }
            if (!this._coustomVariables) {
                // var x = -dt * this._speed;
                // group2.translateZ(x);
                //   console.log(x);


            }




        }

        if (this._mode == "blink") {

            blinkSphersN[R].material.transparent = false;
            blinkSphersN[R].visible = true;
            blinkSphersN[R].material.opacity = 0;
            blinkSphersN[R].material.color.setHex(0x000000)
            blinkSphersN[R].scale.set(2, 2, 2);

            new TWEEN.Tween(blinkSphersN[R].material)
                .to({ opacity: 1 }, 700)
                .easing(TWEEN.Easing.Quadratic.Out).start();



        }


    }
    update(dt_, elevationsMeshList) {


        // if (Object.keys(this._gamePads).length > 0) {
        //     for (let key in Object.keys(this._gamePads)) {
        //         if (this._enabled[key]) {
        //             const gp = this._gamePads[key];
        //             if (gp.buttons[3].presjssed) {
        //                 //console.log("hapticActuators = " + gp.hapticActuators)
        //                 //console.log(gp.axes[0] + " " + gp.axes[1] + " " + gp.axes[2] + " " + gp.axes[3])
        //                 this._activeController = this._controllers[key];
        //                 this._TPoints.forEach(myFunction1);

        //                 function myFunction1(item, index) {
        //                     item.fadeIn(1);
        //                      console.log("pressed");
        //                 }


        //                // teleports[0].selected=true;
        //             }
        //             if (gp.buttons[3].released) {
        //                 console.log("D");
        //             }
        //         }
        //     }
        // }


        // this.workingMatrix.identity().extractRotation(this._activeController.matrixWorld);

        // raycaster.ray.origin.setFromMatrixPosition(this._activeController.matrixWorld);
        // raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(this.workingMatrix);


 
        // const intersects = raycaster.intersectObjects(this._TPoints);


        // if (intersects.length > 0) {
        //     //   console.log(intersect);
        //     const intersect = intersects[0];

        //     if (intersect.object.parent instanceof TeleportMesh) {
        //         intersect.object.parent.selected = true;
               
        //     }
        // }



        // teleports.forEach(teleport => {
        //     teleport.update(dt_);
        // });
        camera = group2.children[0];
        cameraRotaion = group2.children[0].quaternion.clone();
        controller1 = group2.children[1];
        controller1Rotation = group2.children[1].quaternion.clone();
        controller2 = group2.children[2];
        controller2Rotaion = group2.children[2].quaternion.clone();

        var R = this._radiusIndex;
        //console.log(this._pressed);

        //console.log(pressed);
        if (pressed == true) {


            // this._TPoints.forEach(myFunction1);

            // function myFunction1(item, index) {
            //     item.fadeIn(1);
            //     console.log("ss");
            // }

            // this.fly();
            // dt = dt_;
            //console.log(this._coustomVariables);
        }
        if (!pressed) {


            // this._TPoints.forEach(myFunction2);

            // function myFunction2(item, index) {

            //     item.fadeOut(1);
            // }

            // 
            new TWEEN.Tween(blinkSphersN[R].material).to({ opacity: 0 }, 600).start();
            blinkSphersN[R].visible = false;
        }


        if (this._coustomVariables) {


            if (this._pressedFunction != "") {
                var s = eval('(function() {' + this._pressedFunction + '}())');
                this._newpressed = s;
                // console.log(s);
            }



            if (this._newpressed == true) {
                this.fly();
                dt = dt_;

            }
            else {
                // console.log(blinkSphersN[R]);
                new TWEEN.Tween(blinkSphersN[R].material).to({ opacity: 0 }, 600).start();
                blinkSphersN[R].visible = false;
            }
        }
    }
}
